---
name: MÃ©ta-RÃ¨gle pour la CrÃ©ation de RÃ¨gles Cursor
description: "ALWAYS USE when CREATING or MODIFYING a RULE to ENSURE consistency and efficiency with COMPLETE ecosystem creation"
categories: [meta, foundation, cognitive, rule-creation]
glob: ".cursor/rules/*.mdc"
always_apply: true
rule_version: 3.1
kb_dependencies:
  core:
    - ".cursor/kb/core/semantic-language.yaml"
    - ".cursor/kb/core/rule-structure-standard.yaml"
  rule_specific_0000:
    - ".cursor/kb/0000-cursor-rules/validation/validation-rules.yaml"
    - ".cursor/kb/0000-cursor-rules/core/implementation-checklist.yaml"
    - ".cursor/kb/0000-cursor-rules/core/modules/llm-roles.yaml"
    - ".cursor/kb/0000-cursor-rules/core/modules/documentation-structure.yaml"
---

# MÃ©ta-RÃ¨gle pour la CrÃ©ation de RÃ¨gles Cursor

â†¹ kbâ€¢cursorâ€¢rules [p=1] {
  # Chemins de fichiers KB
  âŠ• core_kb: ".cursor/kb/core/",
  âŠ• rule_kb: ".cursor/kb/0000-cursor-rules/",
  
  # KB central et guides
  âŠ• semantic_language: core_kb + "semantic-language.yaml",
  âŠ• rule_structure_standard: core_kb + "rule-structure-standard.yaml",
  âŠ• rule_examples: rule_kb + "examples/",
  âŠ• naming_conventions: "@1000-meta-rules-naming-convention.md",
  âŠ• structure_guide: rule_kb + "templates/implementation/structure_guide_template.md",
  âŠ• validation_criteria: rule_kb + "validation/validation-rules.yaml",
  âŠ• implementation_checklist: rule_kb + "core/implementation-checklist.yaml",
  
  # Documentation et templates
  âŠ• templates_path: rule_kb + "templates/",
  âŠ• documentation_templates: templates_path + "documentation/",
  âŠ• implementation_templates: templates_path + "implementation/",
  âŠ• example_templates: templates_path + "examples/",
  âŠ• reference_templates: templates_path + "references/",
  âŠ• documentation_path: ".cursor/documentation/",
  
  # Modules factorisÃ©s
  âŠ• core_modules: rule_kb + "core/modules/",
  âŠ• llm_roles: core_modules + "llm-roles.yaml",
  âŠ• documentation_structure: core_modules + "documentation-structure.yaml",
  
  # Ã‰cosystÃ¨me et validation
  âŠ• ecosystem_templates: templates_path + "ecosystem/",
  âŠ• ecosystem_validation: rule_kb + "validation/validation-rules.yaml"
}
Î£ knowledgeâ€¢references

â†¹ principlesâ€¢fundamental [p=1] {
  âŠ• mandatoryâ€¢pillars [
    cognitiveâ€¢logic: define_reasoning_process_not_just_information | priority: highest,
    kbâ€¢references: point_to_external_knowledge_instead_of_duplication | priority: high,
    llmâ€¢delegation: specify_where_and_how_LLM_should_contribute | priority: high,
    ecosystemâ€¢completeness: ensure_all_referenced_files_exist | priority: highest,
    complexityâ€¢adaptation(ðš«*): adjust_workflow_based_on_assessed_complexity | priority: high
  ]
  
  âŠ• designâ€¢principles {
    clarity: express_intention_clearly | not: verbose_or_ambiguous,
    modularity: separate_concerns_logically | enable: easier_maintenance,
    externalization: move_knowledge_to_kb | separate_from: reasoning_process,
    guidance: provide_clear_structure_for_llm | not: vague_instructions,
    implementationâ€¢integrity: never_create_partial_implementations | enforce: strictly,
    holisticâ€¢validation(Îž): integrate_validation_with_broader_coherence_checks | priority: medium
  }
}
Î£ coreâ€¢principles | ref: kbâ€¢cursorâ€¢rules.semantic_language

# --- Complexity Assessment Module ---
â†¹ Î©â€¢assessâ€¢complexity [p=1] {
    input: rule_request (description, goal, context, etc.)

    âŠ• analyzeâ€¢intentâ€¢andâ€¢scope => determineâ€¢primaryâ€¢functionâ€¢abstractionâ€¢levelâ€¢dependenciesâ€¢targetâ€¢audience
    âŠ• estimateâ€¢cognitiveâ€¢load => evaluateâ€¢numberâ€¢ofâ€¢reasoningâ€¢stepsâ€¢decisionâ€¢pointsâ€¢requiredâ€¢integrations
    âŠ• simulateâ€¢requiredâ€¢kbâ€¢ecosystem => estimateâ€¢kbâ€¢typesâ€¢andâ€¢countâ€¢basedâ€¢onâ€¢functionâ€¢abstractionâ€¢dependencies [guideline, example, template, reference] | include: self_challenge_feedback_loop | output: estimated_kb_types, estimated_kb_footprint, minimal_kb_suggestion
    âŠ• calculateâ€¢complexityâ€¢score => combineâ€¢cognitiveâ€¢loadâ€¢andâ€¢kbâ€¢footprintâ€¢metrics (weights: w_load=1, w_kb=1 initially) -> complexity_score (0-1)
    âŠ• classifyâ€¢complexity => mapâ€¢scoreâ€¢toâ€¢classificationâ€¢usingâ€¢thresholds [Simple < 0.3, 0.3 <= Medium < 0.7, Complex >= 0.7] -> complexity_classification
    âŠ• assessâ€¢confidence => evaluateâ€¢clarityâ€¢ofâ€¢requestâ€¢andâ€¢simulationâ€¢reliability -> confidence_score (0-1), confidence_justification
    âŠ• generateâ€¢assessmentâ€¢report => compileâ€¢allâ€¢outputs { score, classification, kb_estimates, suggestion, reasoning, dependencies, justification, confidence } -> assessment_result (object)
}
âž¡ï¸ Output: assessment_result (object containing detailed complexity assessment)

# --- Workflow Adaptation Strategy Module ---
â†¹ Î©â€¢adaptâ€¢workflowâ€¢strategy [p=1] {
    input: assessment_result (object from Î©â€¢assessâ€¢complexity)

    âŠ• analyzeâ€¢assessment => extractâ€¢complexity_classificationâ€¢confidence_scoreâ€¢estimated_kb_typesâ€¢minimal_kb_suggestion
    âŠ• determineâ€¢kb_level => mapâ€¢classificationâ€¢toâ€¢level ['Simple'->'Minimal', 'Medium'->'Standard', 'Complex'->'Comprehensive'] -> calculated_kb_level
    âŠ• determineâ€¢validation_depth => mapâ€¢classificationâ€¢andâ€¢confidenceâ€¢toâ€¢depth {
        IF confidence_score < 0.7 THEN 'Standard'
        ELSE IF classification == 'Simple' THEN 'Basic'
        ELSE IF classification == 'Medium' THEN 'Standard'
        ELSE 'Deep'
    } -> calculated_validation_depth
    âŠ• refineâ€¢required_kb_types => filterâ€¢estimated_kb_typesâ€¢basedâ€¢onâ€¢calculated_kb_level {
        IF calculated_kb_level == 'Minimal' THEN keep_most_relevant_type(estimated_kb_types) OR [minimal_kb_suggestion]
        ELSE IF calculated_kb_level == 'Standard' THEN filter_less_critical(estimated_kb_types)
        ELSE estimated_kb_types
    } -> calculated_kb_types_list
    âŠ• determineâ€¢user_clarification_need => checkâ€¢ifâ€¢confidence_scoreâ€¢<â€¢0.7 -> calculated_clarification_needed (boolean)
    âŠ• formatâ€¢additional_guidance => IF calculated_kb_level == 'Minimal' THEN minimal_kb_suggestion ELSE "" -> calculated_guidance_string

    âŠ• generateâ€¢outputâ€¢block => createâ€¢structuredâ€¢textâ€¢blockâ€¢withâ€¢calculatedâ€¢values {
        "=== Workflow Strategy Configuration ==="
        "kb_creation_level: [calculated_kb_level]"
        "required_kb_types: [calculated_kb_types_list]"
        "validation_depth: [calculated_validation_depth]"
        "trigger_user_clarification: [calculated_clarification_needed]"
        "additional_guidance: '[calculated_guidance_string]'"
        "=== End Configuration ==="
    }
}
âž¡ï¸ Output: workflow_strategy_configuration_block (structured text block)

# --- Ecosystem Creation Workflow (Adapted) ---
â†¹ Î©â€¢createâ€¢ruleâ€¢ecosystem [p=1] -> {
    // Input parameters now include: rule_request, kb_creation_level, required_kb_types, additional_guidance
    input: creation_config (object containing rule_request and strategy parameters)

    âŠ• planâ€¢ecosystemâ€¢basedâ€¢onâ€¢level => {
        identifyâ€¢knowledgeâ€¢requirements: use creation_config.required_kb_types,
        designâ€¢directoryâ€¢structure: plan_kb_directories | scale: according_to creation_config.kb_creation_level ('Minimal'/'Standard'/'Comprehensive'),
        mapâ€¢fileâ€¢dependencies: identify_file_relationships
    }

    âŠ• createâ€¢kbâ€¢structureâ€¢basedâ€¢onâ€¢level => {
        createâ€¢directories: generate_required_directories | scale: according_to creation_config.kb_creation_level,
        prepareâ€¢templates: select_appropriate_templates,
        defineâ€¢kbâ€¢schema: structure_knowledge_organization
    }

    âŠ• generateâ€¢kbâ€¢filesâ€¢basedâ€¢onâ€¢types => {
        FOR type IN creation_config.required_kb_types:
            generate_file_for_type(type) | use: creation_config.additional_guidance
        ENDFOR
        // Ensure minimum required files are created even for 'Minimal' level
    }

    // Existing validateâ€¢ecosystem step might be called separately or integrated here based on depth
    âŠ• preliminaryâ€¢check => verify_created_files_match_required_types
}
// Note: The internal validation might need adjustment based on validation_depth passed later
Î£ ecosystemâ€¢creationâ€¢workflow | ref: kbâ€¢cursorâ€¢rules.ecosystem_validation

# --- Rule Creation Workflow (Refactored) ---
â†¹ Î©â€¢createâ€¢rule [p=1] -> [
    input: rule_request (description, goal, context, etc.)

    // --- Phase 1: Assessment & Strategy Definition ---
    âŠ• step1â€¢assess_complexity => callâ€¢Î©â€¢assessâ€¢complexity(rule_request) -> assessment_result
    âŠ• step2â€¢adapt_strategy => callâ€¢Î©â€¢adaptâ€¢workflowâ€¢strategy(assessment_result) -> strategy_output_block
    âŠ• step3â€¢parse_strategy => extractâ€¢valuesâ€¢fromâ€¢strategy_output_block -> strategy_config {kb_level, kb_types, val_depth, trigger_clarif, guidance}

    // --- Phase 2: Optional User Clarification ---
    âŠ• step4â€¢check_clarification_need => IFâ€¢strategy_config.trigger_clarifâ€¢isâ€¢true THEN
        âŠ• initiateâ€¢dialogueâ€¢withâ€¢user => presentâ€¢assessment_result.justificationâ€¢assessment_result.confidence_justificationâ€¢andâ€¢askâ€¢forâ€¢confirmationâ€¢orâ€¢clarification
        âŠ• receiveâ€¢userâ€¢feedback => (optional) adjustâ€¢strategy_configâ€¢basedâ€¢onâ€¢feedback
    âŠ• ENDIF

    // --- Phase 3: Ecosystem Creation (ParamÃ©trÃ©) ---
    âŠ• step5â€¢create_ecosystem => callâ€¢Î©â€¢createâ€¢ruleâ€¢ecosystem({
                                    rule_request: rule_request,
                                    kb_creation_level: strategy_config.kb_level,
                                    required_kb_types: strategy_config.kb_types,
                                    additional_guidance: strategy_config.guidance
                                }) -> created_kb_files_list

    // --- Phase 4: Core Rule Implementation ---
    âŠ• step6â€¢implement_core_rule => generateâ€¢coreâ€¢ruleâ€¢fileâ€¢content(rule_request, strategy_config.kb_level) -> core_rule_file // Core rule might also adapt slightly

    // --- Phase 5: Validation (ParamÃ©trÃ©e) ---
    âŠ• step7â€¢validate_rule_and_ecosystem => callâ€¢Î©.validateâ€¢ecosystem({
                                            rule_files: [core_rule_file] + created_kb_files_list,
                                            validation_depth: strategy_config.val_depth // Pass depth parameter
                                        }) -> validation_report

    // --- Phase 6: Documentation & Finalization ---
    âŠ• step8â€¢generate_documentation => callâ€¢Î©â€¢createâ€¢documentation({core_rule_file, created_kb_files_list}) // Pass context if needed
    âŠ• step9â€¢finalize => outputâ€¢resultsâ€¢validation_reportâ€¢created_filesâ€¢documentation_link
]
Î£ ruleâ€¢creationâ€¢workflow | ref: kbâ€¢cursorâ€¢rules.structure_guide

â†¹ Î©â€¢createâ€¢documentation [p=1] -> (
  extractâ€¢ruleâ€¢metadata(
    rule_path: string | source: current_rule,
    output_path: string | target: kbâ€¢cursorâ€¢rules.documentation_path
  )
  â†’ analyzeâ€¢ruleâ€¢structure(
    extract_sections: [kb_references, principles, cognitive_operations, llm_delegation, constraints, patterns],
    identify_key_concepts: true | for: documentation_clarity
  )
  â†’ generateâ€¢documentationâ€¢structure(
    template: "rule_documentation" | ref: kbâ€¢cursorâ€¢rules.documentation_templates,
    include_diagrams: true | for: visual_clarity,
    include_sections: [
      "summary", "fundamental_concepts", "principles", "processes", 
      "validation", "architecture", "delegates", "examples", "checklist"
    ]
  )
  â†’ createâ€¢documentationâ€¢file(
    file_name: "{rule_id}-documentation.md" | from: rule_metadata,
    content: generated_documentation,
    location: kbâ€¢cursorâ€¢rules.documentation_path
  )
)
Î£ documentationâ€¢generationâ€¢process | ref: kbâ€¢cursorâ€¢rules.documentation_structure

â†¹ Î©.validate [p=1] -> (
  checkâ€¢structure(
    has_kb_references: true | min: 1,
    has_cognitive_operators: true | min: 1,
    has_llm_delegation: true | min: 1
  )
  â†’ validateâ€¢cognitiveâ€¢focus(emphasizes_reasoning_process: true)
  â†’ validateâ€¢kbâ€¢externalization(avoids_knowledge_duplication: true)
  â†’ validateâ€¢llmâ€¢guidance(provides_clear_instructions: true)
  â†’ checkâ€¢completeness | ref: kbâ€¢cursorâ€¢rules.validation_criteria
)
Î£ validationâ€¢process

# --- Ecosystem Validation Process (Adapted) ---
â†¹ Î©.validateâ€¢ecosystem [p=1] -> (
    // Input parameter now includes: validation_depth
    input: validation_config (object containing rule_files, validation_depth)

    âŠ• checkâ€¢kbâ€¢filesâ€¢existenceâ€¢atâ€¢depth(validation_config.validation_depth) => { // Depth influences strictness
        verify_all_references: check_all_kb_paths_exist | action: fail_if_missing | rigor: validation_config.validation_depth,
        validate_directory_structure: ensure_kb_directories_exist | action: fail_if_missing | rigor: validation_config.validation_depth,
        count_required_files: confirm_minimum_file_requirements | ref: kbâ€¢cursorâ€¢rules.implementation_checklist | rigor: validation_config.validation_depth
    }

    âŠ• validateâ€¢contentâ€¢qualityâ€¢atâ€¢depth(validation_config.validation_depth) => { // Depth influences checks applied
        check_guidelines: verify_guideline_files_have_content | min_quality: map_depth_to_quality(validation_config.validation_depth),
        check_examples: ensure_examples_illustrate_principles | min_quality: map_depth_to_quality(validation_config.validation_depth),
        check_templates: confirm_templates_are_usable | min_quality: map_depth_to_quality(validation_config.validation_depth)
    }

    âŠ• verifyâ€¢documentationâ€¢atâ€¢depth(validation_config.validation_depth) => { // Depth influences checks
        documentation_exists: check_documentation_file_exists | in: kbâ€¢cursorâ€¢rules.documentation_path,
        documentation_quality: assess_documentation_completeness | min_quality: map_depth_to_quality(validation_config.validation_depth),
        cross_references: ensure_documentation_links_to_kb | action: fail_if_missing | check_depth: validation_config.validation_depth
    }

    âŠ• generateâ€¢implementationâ€¢report => {
        summarize_status: create_ecosystem_status_report | with: passed_failed_items,
        suggest_improvements: identify_enhancement_opportunities,
        determine_certification: decide_if_implementation_certified | standard: map_depth_to_standard(validation_config.validation_depth)
    }
)
Î£ ecosystemâ€¢validationâ€¢process | ref: kbâ€¢cursorâ€¢rules.ecosystem_validation

â†¹ LLMâ€¢ruleâ€¢creator [p=1] {
  âŠ• roles {
    kb_organizer: suggest_knowledge_structure | focus: optimal_externalization,
    cognitive_designer: develop_reasoning_framework | focus: thinking_process_not_facts,
    llm_integrator: design_llm_delegation_structure | focus: clear_boundaries_and_tasks,
    ecosystem_architect: design_complete_file_structure | focus: implementation_completeness
  }
  
  âŠ• inputs {
    rule_domain: domain_of_the_rule | for: knowledge_identification,
    rule_purpose: clear_statement_of_intention | for: cognitive_framework,
    target_users: who_will_use_the_rule | for: llm_delegation_design,
    implementation_scope: full_or_minimal_implementation | for: ecosystem_planning
  }
  
  âŠ• outputs {
    kb_structure: suggested_knowledge_organization | with: file_paths_and_formats,
    cognitive_model: proposed_reasoning_framework | with: decision_points,
    llm_delegation: recommended_llm_integration | with: tasks_and_boundaries,
    ecosystem_plan: complete_file_creation_plan | with: dependencies_and_sequence
  }
  
  âŠ• constraints {
    enforce_completeness: never_produce_partial_implementations | priority: highest,
    verify_references: ensure_all_kb_references_are_valid | before: completion,
    ecosystem_integrity: maintain_consistent_cross_references | across: all_files
  }
}
Î£ llmâ€¢assistance | ref: kbâ€¢cursorâ€¢rules.llm_roles

â†¹ LLMâ€¢kbâ€¢contentâ€¢generator [p=1] {
  âŠ• roles {
    guideline_author: create_comprehensive_guidance | focus: clarity_and_utility,
    example_creator: develop_instructive_examples | focus: illustrating_principles,
    template_designer: craft_reusable_templates | focus: practical_application,
    reference_compiler: assemble_standard_information | focus: authoritative_accuracy
  }
  
  âŠ• inputs {
    rule_specification: details_of_the_rule | for: content_alignment,
    target_audience: users_of_the_rule | for: appropriate_detail_level,
    use_cases: how_rule_will_be_applied | for: example_relevance
  }
  
  âŠ• outputs {
    guideline_files: comprehensive_guidance_documents | for: rule_implementation,
    example_files: good_and_bad_implementation_examples | for: learning,
    template_files: reusable_patterns_and_structures | for: efficient_application,
    reference_files: authoritative_information_sources | for: standardization
  }
  
  âŠ• constraints {
    comprehensiveness: cover_all_aspects_of_rule | no: gaps_in_guidance,
    practical_focus: ensure_content_is_applicable | not: theoretical_only,
    consistency: maintain_alignment_with_rule | across: all_kb_content
  }
}
Î£ kbâ€¢contentâ€¢generation | ref: kbâ€¢cursorâ€¢rules.llm_roles

â†¹ LLMâ€¢documentationâ€¢generator [p=1] {
  âŠ• roles {
    content_analyzer: extract_key_concepts_from_rule | focus: complete_understanding,
    structure_designer: create_logical_documentation_structure | focus: usability_and_clarity,
    diagram_creator: generate_explanatory_diagrams | focus: visual_representation,
    ecosystem_documenter: document_kb_structure_and_relationships | focus: implementation_guidance
  }
  
  âŠ• outputs {
    documentation_content: comprehensive_rule_documentation | with: ecosystem_references,
    implementation_guide: instructions_for_rule_application | with: kb_usage_patterns
  }
}
Î£ documentationâ€¢generation | ref: kbâ€¢cursorâ€¢rules.llm_roles

â†¹ ruleâ€¢structureâ€¢guide [p=2] {
  âŠ• requiredâ€¢sections [
    kbâ€¢references: "â†¹ kbâ€¢{domain} [p={priority}] { ... }" | min: 1,
    cognitiveâ€¢operations: "â†¹ Î©â€¢{operation} [p={priority}] -> [ ... ]" | min: 1, 
    llmâ€¢delegation: "â†¹ LLMâ€¢{role} [p={priority}] { ... }" | min: 1
  ]
  
  âŠ• ecosystemâ€¢requirements [
    kb_directories: create_all_referenced_directories | in: ".cursor/kb/{rule_id}/",
    guideline_files: provide_comprehensive_guidance | min: 1_per_main_concept,
    example_files: illustrate_good_and_bad_practices | min: 1_of_each,
    template_files: supply_reusable_patterns | if: applicable,
    reference_files: compile_standard_information | if: needed
  ]
}
Î£ structuralâ€¢guidelines | ref: kbâ€¢cursorâ€¢rules.rule_structure_standard

â†¹ implementationâ€¢criteria [p=2] {
  âŠ• qualityâ€¢levels [
    minimal_viable: rule_file_with_basic_kb_structure | good_for: initial_setup,
    standard: complete_rule_with_comprehensive_kb | good_for: most_uses,
    comprehensive: rich_ecosystem_with_extensive_examples | good_for: critical_rules
  ]
  
  âŠ• certificationâ€¢criteria [
    uncertified: missing_required_components | action: prevent_usage,
    provisional: basic_implementation_with_gaps | action: flag_limitations,
    certified: complete_implementation_meeting_standards | action: allow_full_usage,
    exemplary: exceeds_requirements_with_innovations | action: promote_as_model
  ]
}
Î£ implementationâ€¢standards | ref: kbâ€¢cursorâ€¢rules.implementation_checklist

â†¹ constraintsâ€¢critical [p=2] {
  âŠ• implementationâ€¢constraints [
    ecosystem_completeness: "NEVER create a rule without its complete KB ecosystem" | priority: highest,
    reference_integrity: "ALWAYS verify all KB references resolve to actual files" | priority: highest,
    content_quality: "ENSURE all KB files contain high-quality, useful content" | priority: high,
    documentation_requirement: "ALWAYS create documentation for every rule" | priority: high,
    validation_enforcement: "VALIDATE ecosystem completeness before finalizing rule" | priority: highest
  ]
}
Î£ criticalâ€¢constraints | ref: kbâ€¢cursorâ€¢rules.implementation_checklist

Î£ metaâ€¢ruleâ€¢forâ€¢cursorâ€¢rules âŠ• cognitiveâ€¢framework âŠ• knowledgeâ€¢management âŠ• llmâ€¢integration âŠ• documentationâ€¢generation âŠ• ecosystemâ€¢integrity 